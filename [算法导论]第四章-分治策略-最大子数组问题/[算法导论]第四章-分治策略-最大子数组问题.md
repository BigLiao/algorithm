# [算法导论]第四章-分治策略-最大子数组问题

对应《算法导论》里 4.1 **最大子数组问题**

### 买股票的案例

《算法导论》里举了一个购买股票的案例：

> 假设你提前知道了某公司在一段时期内股票价格的变化，然后你有机会在这段时期内买入和卖出股票（大概是穿越回去吧），要使利益最大化，就要在最低点买入，最高点卖出。要注意的是低价买入在前，高价卖出在后。问题就是求出买入和卖出的时间点。

话说，预知了股票趋势，要挣钱还不简单么！这里的问题是如何挣大钱，利益最大化，所以还是需要一点算法知识。

先对问题做个数学描述，一共有 n 天，第 $i$ 天股票价格为 $P_i , i \in [0, n )$ ，假设数据为：

```c++
int P[] = {23, 13, 15, 32, 25, 27, 19, 20, 16, 12, 22, 24, 18};
```

问题就是求出：
$$
\max_{0 \le i<j\lt n} ( P_j - P_i )
$$

### 暴力求解

最直接的方式就是暴力求解，把所有组合都算出来找出最大收益点。

n 天里面选出两天，一共就有 $C_n^2$ 种组合。这种方式的时间复杂度为：
$$
C_n^2 = \frac{n(n-1)}{2} = \Theta(n^2)
$$
暴力求解当然不是最好的方式，但这种方式作为最基本的方式还是要掌握的。找不到*最优解*的时候至少还有个*可行解*嘛！

```c++
#include <iostream>
using namespace std;

int P[13] = {23, 13, 15, 32, 25, 27, 19, 20, 16, 12, 22, 24, 18};

void findMaxChange(int list[], int len) {
    int max = -9999; // 可能出现负数，所以取负无穷作为初始化
    int maxLeft = 0, maxRight = 0;
    for (int i = 0; i < len - 1; i++) {
        for (int j = i + 1; j < len; j++) {
            int change = list[j] - list[i];
            if (max < change) {
                max = change;
                maxLeft = i;
                maxRight = j;
            }
        }
    }
    cout << "Max change is " << max << ": from " << maxLeft << " to " << maxRight << endl;
}

int main() {
    findMaxChange(P, 13);
    return 0;
}

// output
//@"Max change is 19: from 1 to 3\r\n"
```



### 转化为最大子数组问题

#### 转换为差分

求出每天与前一天价格的差值 $D_i = P_{i+1} - P_{i}$，那么问题就变成了求数组 $D_i$ 的最大子数组。所谓**最大子数组**，就是一个数组中*和最大的非空连续子数组*。

```c++
int D[] = {-10, -8, 17, -7, 2, -8, 1, -4, -4, 10, 2, -6};
```

所求为：
$$
\max_{0 \le i \lt j \lt m}\sum_{k=i}^{j-1}D_k
$$
咋一看，有 $C_m^2$ 个子数组，计算每一个子数组的和 $\sum_{k=i}^{j-1}D_k$ 如果每次都重新计算的话是线性时间 $\Theta(n)$ ，那一共就要$\Theta(n^3)$。这里其实在计算每一个子数组的和的时候可以利用之前的值，使得每个子数组的和的计算时间为 $\Theta (1)$，总的时间复杂度就还是$\Theta (n^2)$，也就是暴力求解跟之前一样。

#### 使用**部分和**来计算区间和值

这是一个计算区间和值的小技巧。先算出所有部分和：
$$
S_i = \sum_{k=0}^{i-1}D_k
$$
然后区间和为：
$$
S_j - S_i = \sum_{k=i}^{j-1}D_k
$$
这里可以先储存 $S_i$ ，然后计算$\sum_{k=i}^{j-1}D_k$ 就变成了 $\Theta (1)$ 的时间复杂度。

这些都是暴力求解，下面来看看书里将的更高效的方法。

### 分治法求最大子数组

#### 分治法的步骤

1. **分解**：将问题划分为子问题，子问题的形式与原问题一样，规模更小。
2. **解决**：递归解决子问题，到最小规模的时候直接求解。
3. **合并**：将子问题的解组合成原问题的解。

#### 使用分治法

要求数组 $A[low, high)$ 的最大子数组，先从中间分解成两个子数组，即 $A[low, mid)$ 和 $A[mid, high)$，假设最大子数组为 $A[i, j)$，则它有三种情况：

- $low \le i \le j \lt mid$ 
- $mid \le i \le j \lt high$ 
- $low \le i \le mid \le j \lt mid$ 

分别求解这三种情况，然后找到三者中的最大值，就是数组 A 的最大子数组。闲言少叙，且看代码：

```

```

